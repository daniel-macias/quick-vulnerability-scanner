import React, { FC, useEffect, useState } from 'react';
import axios from 'axios';
import ReactApexChart from 'react-apexcharts';
import { ApexOptions } from 'apexcharts';

import { downloadJson } from '@/utils/jsonUtils';
import { unixTimestampToDateString } from '@/utils/dateUtils';
import { TbFaceIdError } from "react-icons/tb";

interface FileResultsProps {
  data: any;
}

const FileResults: FC<FileResultsProps> = ({ data }) => {
  const [analysesData, setAnalysesData] = useState<any>({});
  const [donutSeries, setDonutSeries] = useState<number[]>([]);
  const [generatedError, setGeneratedError] = useState({});

  useEffect(() => {
    const script = document.createElement("script");
    script.type = "module";
    script.src = "https://cdn.jsdelivr.net/npm/ldrs/dist/auto/cardio.js";
    document.head.appendChild(script);

    return () => {
      document.head.removeChild(script);
    };
  }, []);

  // Use the useEffect hook to update the data when the prop 'data' changes
  useEffect(() => {
    handleGetAnalyses();
    
  }, [data]);

  useEffect(() => {
    let intervalId : NodeJS.Timeout;

    const startPolling = () => {
      intervalId = setInterval(async () => {
        await handleGetAnalyses();
      }, 40000);
    };

    const stopPolling = () => {
      clearInterval(intervalId);
    };

    if (analysesData.data?.attributes?.status == "queued") {
      startPolling();
    }

    return () => {
      stopPolling();
    };
  }, [analysesData.data?.attributes?.status]);

  const handleGetAnalyses = async () => {
    
    try {
      // Use the server-side API route we created earlier for IP scanning
      const id = data.data.id;
      const response = await axios.post('/api/analyses/' , {id} );
  
      // Extract the scan result from the response
      const scanResult = response.data;
  
      // Call the onScan callback with the result
      setGeneratedError("");
      setAnalysesData(scanResult);
    } catch (error) {
      console.error('Error scanning FILE:', error);
      setGeneratedError(data);
    }

  };

  const donutChartOptions: ApexOptions = {
    chart: {
      type: 'donut',
      dropShadow: {
        enabled: true,
      },
      
    },
    
    labels: ['Harmless', 'Malicious', 'Suspicious', 'Timeout', 'Undetected', 'Confirmed Timeout', 'Failure', 'Type Not Supported'], 
    colors: ['#00E396', '#FF4560', '#FEB019', '#A5978B', '#008FFB'],
    dataLabels: {
      enabled: true,
      style: {
        fontSize: '14px', // Adjust font size as needed
        colors: ['#ffffff'], // Text color
        fontWeight: '400'
      },
      background: {
        enabled: true,
        foreColor: '#fff', // Foreground color for the label text
        borderColor: '#fff', // Border color
        borderWidth: 2, // Border width
        borderRadius: 0, // Border radius for rounded corners
        padding: 4, // Padding around the text
        opacity: 0.2, // Background opacity
      },
      dropShadow: {
        enabled: true,
        top: 1,
        left: 1,
        blur: 5,
        opacity: 0.45,
      }
    },
    responsive: [{
      breakpoint: 480,
      
      options: {
        chart: {
          width: "100%",
        },
        legend: {
          position: 'bottom',
          labels: {
            colors: '#ffffff', // This directly sets the legend text color
            useSeriesColors: false // Ensure the series colors are not used for text
          }
        },
      },
    }],
    stroke: {
      show: false,
    },
    legend: {
      labels: {
        colors: '#ffffff', // Ensuring the text color is white for all screen sizes
        useSeriesColors: false,
      },
    },
  };

  useEffect(() => {
    
    if(data.data){
      setGeneratedError("");
      if(data.data.attributes){
        setDonutSeries([
          data.data.attributes.stats.harmless, 
          data.data.attributes.stats.malicious, 
          data.data.attributes.stats.suspicious, 
          data.data.attributes.stats.timeout, 
          data.data.attributes.stats.undetected,
          data.data.attributes.stats["confirmed-timeout"],
          data.data.attributes.stats.failure,
          data.data.attributes.stats["type-unsupported"]]);
      }
      
      
    }else{
      setGeneratedError(data);
    }
  }, [data]);

  return (
    <div>
      {generatedError === "" && analysesData.data && analysesData.data.attributes && analysesData.data.attributes.status != "queued" ? (
        <>
          <p>{analysesData.data.attributes.status}</p>
        </>
      ): generatedError === "" &&  (

        <>
          <div className="flex items-center pb-4">
          <p className="px-4">Your data is queued, please wait! This should only take a minute.
          </p>
          <l-cardio
            size="120"
            stroke="10"
            speed="2" 
            color="white" 
          ></l-cardio>
          </div>
        </>
        
      )}

      {generatedError !== "" && (
        <div> 
          <div className="flex flex-col items-center text-center py-8">
          <p className="px-4">Error: The file provided is not valid</p>
            <TbFaceIdError size={50} className="text-[#e65252]"/>
            <p className="px-4">Please provide a file smaller than 32MB</p>
          </div>
          
        </div>
      )}
    </div>
  )
}

export default FileResults