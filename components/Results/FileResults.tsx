import React, { FC, useEffect, useState } from 'react';
import axios from 'axios';
import ReactApexChart from 'react-apexcharts';
import { ApexOptions } from 'apexcharts';

import { downloadJson } from '@/utils/jsonUtils';
import { TbFaceIdError } from "react-icons/tb";

interface FileResultsProps {
  data: any;
}

const FileResults: FC<FileResultsProps> = ({ data }) => {
  const [analysesData, setAnalysesData] = useState<any>({});
  const [donutSeries, setDonutSeries] = useState<number[]>([]);
  const [generatedError, setGeneratedError] = useState({});

  useEffect(() => {
    const script = document.createElement("script");
    script.type = "module";
    script.src = "https://cdn.jsdelivr.net/npm/ldrs/dist/auto/cardio.js";
    document.head.appendChild(script);

    return () => {
      document.head.removeChild(script);
    };
  }, []);

  // Use the useEffect hook to update the data when the prop 'data' changes
  useEffect(() => {
    handleGetAnalyses();
    
  }, [data]);

  useEffect(() => {
    let intervalId : NodeJS.Timeout;

    const startPolling = () => {
      intervalId = setInterval(async () => {
        await handleGetAnalyses();
      }, 40000);
    };

    const stopPolling = () => {
      clearInterval(intervalId);
    };

    if (analysesData.data?.attributes?.status == "queued") {
      startPolling();
    }

    return () => {
      stopPolling();
    };
  }, [analysesData.data?.attributes?.status]);

  const handleGetAnalyses = async () => {
    
    try {
      // Use the server-side API route we created earlier for IP scanning
      const id = data.data.id;
      const response = await axios.post('/api/analyses/' , {id} );
  
      // Extract the scan result from the response
      const scanResult = response.data;
  
      // Call the onScan callback with the result
      setGeneratedError("");
      setAnalysesData(scanResult);
      
    } catch (error) {
      console.error('Error scanning FILE:', error);
      setGeneratedError(data);
    }

  };

  const donutChartOptions: ApexOptions = {
    chart: {
      type: 'donut',
      dropShadow: {
        enabled: true,
      },
      
    },
    
    labels: ['Harmless', 'Malicious', 'Suspicious', 'Timeout', 'Malware Not Detected', 'Confirmed Timeout', 'Failure', 'Type Not Supported'], 
    colors: ['#00E396', '#FF4560', '#FEB019', '#A5978B', '#008FFB','#8D5B4C','	#F86624','#81D4FA',],
    dataLabels: {
      enabled: true,
      style: {
        fontSize: '14px', // Adjust font size as needed
        colors: ['#ffffff'], // Text color
        fontWeight: '400'
      },
      background: {
        enabled: true,
        foreColor: '#fff', // Foreground color for the label text
        borderColor: '#fff', // Border color
        borderWidth: 2, // Border width
        borderRadius: 0, // Border radius for rounded corners
        padding: 4, // Padding around the text
        opacity: 0.2, // Background opacity
      },
      dropShadow: {
        enabled: true,
        top: 1,
        left: 1,
        blur: 5,
        opacity: 0.45,
      }
    },
    responsive: [{
      breakpoint: 480,
      
      options: {
        chart: {
          width: "100%",
        },
        legend: {
          position: 'bottom',
          labels: {
            colors: '#ffffff', // This directly sets the legend text color
            useSeriesColors: false // Ensure the series colors are not used for text
          }
        },
      },
    }],
    stroke: {
      show: false,
    },
    legend: {
      position: 'bottom',
      labels: {
        colors: '#ffffff', // Ensuring the text color is white for all screen sizes
        useSeriesColors: false,
      },
    },
  };


  useEffect(() => {
    if(analysesData.data && analysesData.data.attributes){
      setDonutSeries([
        analysesData.data.attributes.stats.harmless, 
        analysesData.data.attributes.stats.malicious, 
        analysesData.data.attributes.stats.suspicious, 
        analysesData.data.attributes.stats.timeout, 
        analysesData.data.attributes.stats.undetected,
        analysesData.data.attributes.stats["confirmed-timeout"],
        analysesData.data.attributes.stats.failure,
        analysesData.data.attributes.stats["type-unsupported"]]);
    }
  }, [analysesData]);


  return (
    <div>
      {generatedError === "" && analysesData.data && analysesData.data.attributes && analysesData.data.attributes.status != "queued" ? (
        <>
        <div className='grid md:grid-cols-5'>
        <div className="grid md:grid-rows-6 md:col-span-3 mb-5">
          {/* Left Bottom */}
            <div className="md:row-span-1 bg-[#28282d] h-full rounded-md">
              <h3 className='text-center'>Scan Status: {(analysesData.data.attributes.status).toUpperCase()}</h3>
              <h3 className='text-center'>File Size: {analysesData.meta["file_info"].size} bytes</h3>
            </div>
            <div className="md:row-span-5 bg-[#28282d] h-full rounded-md pt-4">
              <ReactApexChart options={donutChartOptions} series={donutSeries} type="donut" width="380" />
            </div>

            
          </div>
          {/* Right Half */}
          <div className="grid md:col-span-2 text-[#d4d3d8] pb-10 text-center">
            <div className="bg-[#3b3b43] p-4 rounded-lg w-full">
                <h3 className='text-[#ffffff] text-lg pd-4'>Summary</h3>
                <p>Harmless: {donutSeries[0]}</p>
                <p>Malicious: {donutSeries[1]}</p>
                <p>Suspicious: {donutSeries[2]}</p>
                <p>Timeout: {donutSeries[3]}</p>
                <p>Malware Not Detected: {donutSeries[4]}</p>
                <p>Confirmed Timeout: {donutSeries[5]}</p>
                <p>Failure: {donutSeries[6]}</p>
                <p>Type Unsupported: {donutSeries[7]}</p>
                
                
            </div>
            <button onClick={() => downloadJson(analysesData, "fileresults.json")} className="inline-block bg-blue-500 text-white my-4 rounded-md text-xs w-full py-5">
                    Download Full Report
                </button>

          </div>
        </div>
          
          
        </>
      ): generatedError === "" &&  (

        <>
          <div className="flex items-center pb-4">
          <p className="px-4">Your data is queued, please wait! This should only take a minute.
          </p>
          <l-cardio
            size="120"
            stroke="10"
            speed="2" 
            color="white" 
          ></l-cardio>
          </div>
        </>
        
      )}

      {generatedError !== "" && (
        <div> 
          <div className="flex flex-col items-center text-center py-8">
          <p className="px-4">Error: The file provided is not valid</p>
            <TbFaceIdError size={50} className="text-[#e65252]"/>
            <p className="px-4">Please provide a file smaller than 32MB</p>
          </div>
          
        </div>
      )}
    </div>
  )
}

export default FileResults